# FPGA MNIST MLP

This project implements a simple Multi-Layer Perceptron (MLP) in Verilog to classify handwritten digits from the MNIST dataset. The project includes Python scripts for training the model, extracting weights and biases, and generating test images, as well as a Verilog testbench for simulating the hardware model.

## Project Structure

-   `mnist_mlp.v`: The top-level Verilog module for the MNIST MLP.
-   `mnist_mlp_tb.v`: The Verilog testbench for simulating `mnist_mlp.v`.
-   `train_mnist_mlp.py`: A Python script to train the MLP model using TensorFlow/Keras.
-   `extract_weights.py`: A Python script to extract the weights and biases from the trained model, quantize them, and save them as hex files.
-   `get_mnist_image.py`: A Python script to select an image from the MNIST test set and save it as a hex file.
-   `run_test_suite.py`: A Python script to automate the testing of the Verilog model with multiple images from the MNIST test set.
-   `weights.hex`: The quantized weights for the MLP, generated by `extract_weights.py`.
-   `biases.hex`: The quantized biases for the MLP, generated by `extract_weights.py`.
-   `image.hex`: A test image from the MNIST dataset, generated by `get_mnist_image.py`.
-   `lenet-env/`: A Python virtual environment with the necessary dependencies.

## Setup

1.  **Clone the repository:**
    ```bash
    git clone <repository-url>
    cd <repository-directory>
    ```

2.  **Activate the Python virtual environment:**
    The project includes a pre-configured virtual environment `lenet-env/`. To activate it, run:
    ```bash
    source lenet-env/bin/activate
    ```
    If the virtual environment is not available, you can create a new one and install the dependencies:
    ```bash
    python3 -m venv lenet-env
    source lenet-env/bin/activate
    pip install tensorflow numpy
    ```

3.  **Install a Verilog simulator:**
    This project uses `iverilog` and `vvp` for simulation. You can install them using your system's package manager. For example, on Ubuntu/Debian:
    ```bash
    sudo apt-get update
    sudo apt-get install iverilog
    ```

## Usage

### 1. Train the Model

To train the MLP model, run the following command:
```bash
python3 train_mnist_mlp.py
```
This will generate a new `mnist_mlp_model.h5` file containing the trained model.

### 2. Extract Weights and Biases

To extract the weights and biases from the trained model, quantize them, and save them as hex files, run:
```bash
python3 extract_weights.py
```
This will generate `weights.hex` and `biases.hex`.

### 3. Generate Test Image

To select an image from the MNIST test set and save it as a hex file, run:
```bash
python3 get_mnist_image.py
```
This will generate `image.hex`. You can modify the `image_index` variable in the script to select a different image.

### 4. Run Verilog Simulation

To compile and run the Verilog simulation, use the following commands:
```bash
iverilog -o mnist_mlp_tb mnist_mlp.v mnist_mlp_tb.v
vvp mnist_mlp_tb
```
The simulation will use the `weights.hex`, `biases.hex`, and `image.hex` files to perform the classification and will print the predicted digit.

## Running the Test Suite

A Python script is provided to automate the testing of the Verilog model with multiple images from the MNIST test set. To run the test suite, execute:
```bash
python3 run_test_suite.py
```
The script will iterate through the images, run the simulation for each one, and report the number of correct matches. It also provides live accuracy updates every 10 images.

**Note:** The `run_test_suite.py` script will temporarily modify the `get_mnist_image.py` file to select different images. The original content of `get_mnist_image.py` will be restored after the test suite finishes.

By default, the script is configured to test all 9999 images in the test set. You can modify the `start_index` and `end_index` variables in `run_test_suite.py` to test a different range of images.

## Results

The Verilog model was tested on all 10000 images of the MNIST test set. The results are as follows:

-   **Total images tested:** 10000
-   **Correct matches:** 9183
-   **Accuracy:** 91.83%

The full test suite can be run to get the accuracy for all 10000 images. The mismatches are likely due to the quantization of weights and biases, which can cause slight differences in the model's behavior compared to the floating-point Python model.
